<!DOCTYPE html>
<html lang="en" style="scroll-behavior:smooth">
  
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Blog</title>
<style>mark{background-color:#e3e8c9}</style>
<style>@font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,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) format('woff')}body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}body .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}body .anchor:focus{outline:0}body h1 .octicon-link,body h2 .octicon-link,body h3 .octicon-link,body h4 .octicon-link,body h5 .octicon-link,body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}body h1:hover .anchor,body h2:hover .anchor,body h3:hover .anchor,body h4:hover .anchor,body h5:hover .anchor,body h6:hover .anchor{text-decoration:none}body h1:hover .anchor .octicon-link,body h2:hover .anchor .octicon-link,body h3:hover .anchor .octicon-link,body h4:hover .anchor .octicon-link,body h5:hover .anchor .octicon-link,body h6:hover .anchor .octicon-link{visibility:visible}body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-size:16px;line-height:1.5;word-wrap:break-word}body .pl-c{color:#6a737d}body .pl-c1,body .pl-s .pl-v{color:#005cc5}body .pl-e,body .pl-en{color:#6f42c1}body .pl-s .pl-s1,body .pl-smi{color:#24292e}body .pl-ent{color:#22863a}body .pl-k{color:#d73a49}body .pl-pds,body .pl-s,body .pl-s .pl-pse .pl-s1,body .pl-sr,body .pl-sr .pl-cce,body .pl-sr .pl-sra,body .pl-sr .pl-sre{color:#032f62}body .pl-smw,body .pl-v{color:#e36209}body .pl-bu{color:#b31d28}body .pl-ii{background-color:#b31d28;color:#fafbfc}body .pl-c2{background-color:#d73a49;color:#fafbfc}body .pl-c2:before{content:"^M"}body .pl-sr .pl-cce{color:#22863a;font-weight:700}body .pl-ml{color:#735c0f}body .pl-mh,body .pl-mh .pl-en,body .pl-ms{color:#005cc5;font-weight:700}body .pl-mi{color:#24292e;font-style:italic}body .pl-mb{color:#24292e;font-weight:700}body .pl-md{background-color:#ffeef0;color:#b31d28}body .pl-mi1{background-color:#f0fff4;color:#22863a}body .pl-mc{background-color:#ffebda;color:#e36209}body .pl-mi2{background-color:#005cc5;color:#f6f8fa}body .pl-mdr{color:#6f42c1;font-weight:700}body .pl-ba{color:#586069}body .pl-sg{color:#959da5}body .pl-corl{color:#032f62;text-decoration:underline}body details{display:block}body summary{display:list-item}body a{background-color:transparent}body a:active,body a:hover{outline-width:0}body strong{font-weight:inherit;font-weight:bolder}body h1{font-size:2em;margin:.67em 0}body img{border-style:none}body code,body kbd,body pre{font-family:monospace,monospace;font-size:1em}body hr{box-sizing:content-box;height:0;overflow:visible}body input{font:inherit;margin:0}body input{overflow:visible}body [type=checkbox]{box-sizing:border-box;padding:0}body *{box-sizing:border-box}body input{font-family:inherit;font-size:inherit;line-height:inherit}body a{color:#0366d6;text-decoration:none}body a:hover{text-decoration:underline}body strong{font-weight:600}body hr{background:0 0;border:0;border-bottom:1px solid #dfe2e5;height:0;margin:15px 0;overflow:hidden}body hr:before{content:"";display:table}body hr:after{clear:both;content:"";display:table}body table{border-collapse:collapse;border-spacing:0}body td,body th{padding:0}body details summary{cursor:pointer}body h1,body h2,body h3,body h4,body h5,body h6{margin-bottom:0;margin-top:0}body h1{font-size:32px}body h1,body h2{font-weight:600}body h2{font-size:24px}body h3{font-size:20px}body h3,body h4{font-weight:600}body h4{font-size:16px}body h5{font-size:14px}body h5,body h6{font-weight:600}body h6{font-size:12px}body p{margin-bottom:10px;margin-top:0}body blockquote{margin:0}body ol,body ul{margin-bottom:0;margin-top:0;padding-left:0}body dd{margin-left:0}body code,body pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px}body pre{margin-bottom:0;margin-top:0}body input::-webkit-inner-spin-button,body input::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}body .border{border:1px solid #e1e4e8!important}body .border-0{border:0!important}body .border-bottom{border-bottom:1px solid #e1e4e8!important}body .rounded-1{border-radius:3px!important}body .bg-white{background-color:#fff!important}body .bg-gray-light{background-color:#fafbfc!important}body .text-gray-light{color:#6a737d!important}body .mb-0{margin-bottom:0!important}body .my-2{margin-bottom:8px!important;margin-top:8px!important}body .pl-0{padding-left:0!important}body .py-0{padding-bottom:0!important;padding-top:0!important}body .pl-1{padding-left:4px!important}body .pl-2{padding-left:8px!important}body .py-2{padding-bottom:8px!important;padding-top:8px!important}body .pl-3,body .px-3{padding-left:16px!important}body .px-3{padding-right:16px!important}body .pl-4{padding-left:24px!important}body .pl-5{padding-left:32px!important}body .pl-6{padding-left:40px!important}body .f6{font-size:12px!important}body .lh-condensed{line-height:1.25!important}body .text-bold{font-weight:600!important}body:before{content:"";display:table}body:after{clear:both;content:"";display:table}body>:first-child{margin-top:0!important}body>:last-child{margin-bottom:0!important}body a:not([href]){color:inherit;text-decoration:none}body blockquote,body dl,body ol,body p,body pre,body table,body ul{margin-bottom:16px;margin-top:0}body hr{background-color:#e1e4e8;border:0;height:.25em;margin:24px 0;padding:0}body blockquote{border-left:.25em solid #dfe2e5;color:#6a737d;padding:0 1em}body blockquote>:first-child{margin-top:0}body blockquote>:last-child{margin-bottom:0}body kbd{background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5;color:#444d56;display:inline-block;font-size:11px;line-height:10px;padding:3px 5px;vertical-align:middle}body h1,body h2,body h3,body h4,body h5,body h6{font-weight:600;line-height:1.25;margin-bottom:16px;margin-top:24px}body h1{font-size:2em}body h1,body h2{border-bottom:1px solid #eaecef;padding-bottom:.3em}body h2{font-size:1.5em}body h3{font-size:1.25em}body h4{font-size:1em}body h5{font-size:.875em}body h6{color:#6a737d;font-size:.85em}body ol,body ul{padding-left:2em}body ol ol,body ol ul,body ul ol,body ul ul{margin-bottom:0;margin-top:0}body li{word-wrap:break-all}body li>p{margin-top:16px}body li+li{margin-top:.25em}body dl{padding:0}body dl dt{font-size:1em;font-style:italic;font-weight:600;margin-top:16px;padding:0}body dl dd{margin-bottom:16px;padding:0 16px}body table{display:block;overflow:auto;width:100%}body table th{font-weight:600}body table td,body table th{border:1px solid #dfe2e5;padding:6px 13px}body table tr{background-color:#fff;border-top:1px solid #c6cbd1}body table tr:nth-child(2n){background-color:#f6f8fa}body img{background-color:#fff;box-sizing:content-box;max-width:100%}body img[align=right]{padding-left:20px}body img[align=left]{padding-right:20px}body code{background-color:rgba(27,31,35,.05);border-radius:3px;font-size:85%;margin:0;padding:.2em .4em}body pre{word-wrap:normal}body pre>code{background:0 0;border:0;font-size:100%;margin:0;padding:0;white-space:pre;word-break:normal}body .highlight{margin-bottom:16px}body .highlight pre{margin-bottom:0;word-break:normal}body .highlight pre,body pre{background-color:#f6f8fa;border-radius:3px;font-size:85%;line-height:1.45;overflow:auto;padding:16px!important}body pre code{background-color:transparent;border:0;display:inline;line-height:inherit;margin:0;max-width:auto;overflow:visible;padding:0;word-wrap:normal}body .commit-tease-sha{color:#444d56;display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:90%}body .blob-wrapper{border-bottom-left-radius:3px;border-bottom-right-radius:3px;overflow-x:auto;overflow-y:hidden}body .blob-wrapper-embedded{max-height:240px;overflow-y:auto}body .blob-num{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;color:rgba(27,31,35,.3);cursor:pointer;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;line-height:20px;min-width:50px;padding-left:10px;padding-right:10px;text-align:right;user-select:none;vertical-align:top;white-space:nowrap;width:1%}body .blob-num:hover{color:rgba(27,31,35,.6)}body .blob-num:before{content:attr(data-line-number)}body .blob-code{line-height:20px;padding-left:10px;padding-right:10px;position:relative;vertical-align:top}body .blob-code-inner{color:#24292e;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;overflow:visible;white-space:pre;word-wrap:normal}body .pl-token.active,body .pl-token:hover{background:#ffea7f;cursor:pointer}body kbd{background-color:#fafbfc;border:1px solid #d1d5da;border-bottom-color:#c6cbd1;border-radius:3px;box-shadow:inset 0 -1px 0 #c6cbd1;color:#444d56;display:inline-block;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:10px;padding:3px 5px;vertical-align:middle}body :checked+.radio-label{border-color:#0366d6;position:relative;z-index:1}body .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}body .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}body .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}body .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}body .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}body .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}body .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}body .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}body .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}body .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}body .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}body .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}body .task-list-item{list-style-type:none}body .task-list-item+.task-list-item{margin-top:3px}body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}body hr{border-bottom-color:#eee}body .pl-0{padding-left:0!important}body .pl-1{padding-left:4px!important}body .pl-2{padding-left:8px!important}body .pl-3{padding-left:16px!important}body .pl-4{padding-left:24px!important}body .pl-5{padding-left:32px!important}body .pl-6{padding-left:40px!important}body .pl-7{padding-left:48px!important}body .pl-8{padding-left:64px!important}body .pl-9{padding-left:80px!important}body .pl-10{padding-left:96px!important}body .pl-11{padding-left:112px!important}body .pl-12{padding-left:128px!important}</style>
<style>.code-container{position:relative}.hljs textarea{position:absolute;top:0;z-index:-1;opacity:0}.code-container .btn-copy{position:absolute;top:13px;right:4px;background-color:#fff;border:solid 1px rgba(0,0,0,.15);border-radius:2px;color:#363636;cursor:pointer;padding:3px 8px;opacity:0;transition:right .15s ease,opacity .15s ease}.code-container:hover .btn-copy{right:14px;opacity:1}.code-container .btn-copy:hover{border-color:rgba(0,0,0,.3)}.code-container .btn-copy:active{border-color:rgba(0,0,0,.7)}</style>

</head>

<body style="max-width:1024px;margin:auto;padding:100px">
<nav>
  <ul>
    <li><a href="./accessibility">Accessibility</a></li>
    <li><a href="./code-splitting">Code-Splitting</a></li>
    <li><a href="./context">Context</a></li>
    <li><a href="./error-boundaries">Error Boundaries</a></li>
    <li><a href="./refs-and-dom">Refs and the DOM</a></li>
    <li><a href="./forwarding-refs">Forwarding Refs</a></li>
    <li><a href="./higher-order-components.html">Higher-Order 
      Components</a></li>
    <li><a href="./optimizing-performance.html">Optimizing Performance</a></li>
    <li><a href="./portals.html">Portals</a></li>
    <li><a href="./profiler.html">Profilers</a></li>
    <li><a href="./render-props.html">Render Props</a></li>
    <li><a href="#">Hooks</a></li>
      <ul>
        <li><a href="./state-hook.html">Using the State hook</a></li>
        <li><a href="./effect-hook.html">Using the Effect hook</a></li>
        <li><a href="./rules-of-hooks.html">Rules of hooks</a></li>
        <li><a href="./custom-hooks.html">Building   your own hooks</a></li>
      </ul>
  </ul>
</nav>

<h1><a id="hoc" href="https://reactjs.org/docs/higher-order-components.html">Higher-Order Components (HOC)</a></h1>
<p>Ово је техника (pattern) за поновно искоришћавање логике компоненти. То је функција која прима компоненту и враћа нову компоненту.</p>
<pre class="hljs"><code>const EnchancedComponent = higherOrderComponent(WrappedComponent)
</code><textarea id="_23w8gwfp2" rows="1" cols="2">const EnchancedComponent = higherOrderComponent(WrappedComponent)</textarea></pre>
<ul>
<li>HOCs су присутне у разним React библиотекама, као код Redux <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect" target="_blank">connect</a> или Relay <a href="https://relay.dev/docs/en/fragment-container.html" target="_blank">createFragmentContainer</a>.</li>
</ul>
<h3 id="use-hocs-for-cross-cutting-concerns">Use HOCs For Cross-Cutting Concerns</h3>
<pre class="hljs"><code>class CommentList extends React.Component{
  constructor(props){
    super(props);
    this.handleChange = this.handleChangeBind(this);
    this.state = {
      // &quot;DataSource&quot; is some global data source
      comments: DataSource.getComments()
    };
  }
  componentDidMount(){
    // subscribe to changes
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount(){
    // clean up listener
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange(){
    // update component state whenever the data source changes
    this.setState({
      comments: DataSource.getComments()
    });
  }

  render(){
    return (
      &lt;div&gt;
        {this.state.comments.map( comment =&gt; (
          &lt;Comment comment={comment} key={comment.id}&gt;
        ))}
      &lt;/div&gt;
    )
  }

}
</code><textarea id="_6phcz32tp" rows="1" cols="2">class CommentList extends React.Component{
  constructor(props){
    super(props);
    this.handleChange = this.handleChangeBind(this);
    this.state = {
      // &quot;DataSource&quot; is some global data source
      comments: DataSource.getComments()
    };
  }
  componentDidMount(){
    // subscribe to changes
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount(){
    // clean up listener
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange(){
    // update component state whenever the data source changes
    this.setState({
      comments: DataSource.getComments()
    });
  }

  render(){
    return (
      &lt;div&gt;
        {this.state.comments.map( comment =&gt; (
          &lt;Comment comment={comment} key={comment.id}&gt;
        ))}
      &lt;/div&gt;
    )
  }

}</textarea></pre>
<p>Онда напишемо компоненту која се subscribe на један блог пост:</p>
<pre class="hljs"><code>class BlogPost extends React.Component{
  constructor(props){
    super(props);
    this.handleChange = this.handleChangeBind(this);
    this.state = {
      blogPost : DataSource.getBlogPost(props.id);
    };
  }

  componentDidMount(){
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount(){
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange(){
    this.setState({
      blogPost: DataSource.getBlogPost(this.props.id);
    });
  }

  render(){
    return &lt;TextBlock text={this.state.blogPost}/&gt;
  }

}
</code><textarea id="_fms7wcc7c" rows="1" cols="2">class BlogPost extends React.Component{
  constructor(props){
    super(props);
    this.handleChange = this.handleChangeBind(this);
    this.state = {
      blogPost : DataSource.getBlogPost(props.id);
    };
  }

  componentDidMount(){
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount(){
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange(){
    this.setState({
      blogPost: DataSource.getBlogPost(this.props.id);
    });
  }

  render(){
    return &lt;TextBlock text={this.state.blogPost}/&gt;
  }

}</textarea></pre>
<p>Овде видимо да <code>CommentList</code> и <code>BlogPost</code> нису исти, позивају различите методе на <code>DataSource</code> и рендерују различите ствари. Међутим имају и доста сличне имплементације:</p>
<ul>
<li>додавањe и брисање change listener на <code>DataSource</code></li>
<li>унутар listener-a, позивање <code>setState</code> приликом промене извора података</li>
</ul>
<p>За те сличности HOC нам највише одговара, ради креирања апстракције где дефинишемо исту логику коју потом делимо са више компоненти. Тако можемо креирати функцију која прихвата компоненту која прима subscribed data као prop:</p>
<pre class="hljs"><code>const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) =&gt; DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)
);
</code><textarea id="_hf80h4awk" rows="1" cols="2">const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) =&gt; DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)
);</textarea></pre>
<p>Први параметар је компонента коју обрађујемо, а други преузима податке који нам требају са датим <code>DataSource</code> и тренутним props.</p>
<p>Када се ове компоненте рендерују <code>CommentList</code> и <code>BlogPost</code> биће прослеђен <code>data</code> prop са најновијим подацима извученим из <code>DataSource</code>:</p>
<pre class="hljs"><code>// this function takes a component...
function withSubscription(WrappedComponent, selectData){
  // and returns another component...
  return class extends React.Component{
    constructor(props){
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {
        data: selectData(DataSource, props)
      };
    }

  componentDidMount(){
    // takes care of subscription...
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount(){
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange(){
    this.setState({
      data : selectData(DataSource, this.props)
    });
  }

  render(){
    // renders the wrapped component with the fresh data
    // we also pass trough any additional props
    return &lt;WrappedComponent data={this.state.data} {...this.props}/&gt;
  }


  }
}
</code><textarea id="_lsxra0d6c" rows="1" cols="2">// this function takes a component...
function withSubscription(WrappedComponent, selectData){
  // and returns another component...
  return class extends React.Component{
    constructor(props){
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {
        data: selectData(DataSource, props)
      };
    }

  componentDidMount(){
    // takes care of subscription...
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount(){
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange(){
    this.setState({
      data : selectData(DataSource, this.props)
    });
  }

  render(){
    // renders the wrapped component with the fresh data
    // we also pass trough any additional props
    return &lt;WrappedComponent data={this.state.data} {...this.props}/&gt;
  }


  }
}</textarea></pre>
<h3 id="%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0">Проблематика</h3>
<ul>
<li>Не користи HOCs унутар render метода. Reconciliation прави проблем јер компонента за рендеровање није иста ранијој и долази до unmounting и губљења state компоненте.</li>
</ul>
<pre class="hljs"><code>render() {
  // A new version of EnhancedComponent is created on every render
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // That causes the entire subtree to unmount/remount each time!
  return &lt;EnhancedComponent /&gt;;
}
</code><textarea id="_1t7aw5nuz" rows="1" cols="2">render() {
  // A new version of EnhancedComponent is created on every render
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // That causes the entire subtree to unmount/remount each time!
  return &lt;EnhancedComponent /&gt;;
}</textarea></pre>
<p>Уместо тога примени HOC ван дефиниције компоненте, а ако је баш неопходан динамички HOC онда унутар конструктора или lifecycle метода.</p>
<ul>
<li>
<p>статички методи се морају копирати</p>
<p>Приликом примене HOC на компоненту, оригинал се прекрива контејнер компонентом, па нова компонента нема статичке методе оригинала.</p>
</li>
</ul>
<pre class="hljs"><code>  // Define a static method
WrappedComponent.staticMethod = function() {/*...*/}
// Now apply a HOC
const EnhancedComponent = enhance(WrappedComponent);

// The enhanced component has no static method
typeof EnhancedComponent.staticMethod === 'undefined' // true
</code><textarea id="_auhryt05e" rows="1" cols="2">// Define a static method
WrappedComponent.staticMethod = function() {/*...*/}
// Now apply a HOC
const EnhancedComponent = enhance(WrappedComponent);

// The enhanced component has no static method
typeof EnhancedComponent.staticMethod === 'undefined' // true</textarea></pre>
<p>Стога копираш методе на контејнер пре него га вратиш:</p>
<pre class="hljs"><code>function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  // Must know exactly which method(s) to copy :(
  Enhance.staticMethod = WrappedComponent.staticMethod;
  return Enhance;
}
</code><textarea id="_wn8dlqhiv" rows="1" cols="2">function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  // Must know exactly which method(s) to copy :(
  Enhance.staticMethod = WrappedComponent.staticMethod;
  return Enhance;
}</textarea></pre>
<p>Међутим, онда мораш тачно знати које методе копираш. Аутоматски то радиш са <a href="https://github.com/mridgway/hoist-non-react-statics" target="_blank">hoist-non-react-statics</a>, a мануелно са експортом статичног метода из компоненте:</p>
<pre class="hljs"><code>// Instead of...
MyComponent.someFunction = someFunction;
export default MyComponent;

// ...export the method separately...
export { someFunction };

// ...and in the consuming module, import both
import MyComponent, { someFunction } from './MyComponent.js';
</code><textarea id="_0jzgqrar5" rows="1" cols="2">// Instead of...
MyComponent.someFunction = someFunction;
export default MyComponent;

// ...export the method separately...
export { someFunction };

// ...and in the consuming module, import both
import MyComponent, { someFunction } from './MyComponent.js';</textarea></pre>
<ul>
<li>Refs се не прослеђују. Користи <code>forwardRef</code>.</li>
</ul>

</body>
<script src="../node_modules/markdown-to-document/node_modules/clipboard/dist/clipboard.min.js"></script>
<script>document.querySelectorAll("pre.hljs").forEach(function(e){var t=document.createElement("div");t.classList="code-container",e.parentNode.insertBefore(t,e),t.appendChild(e);var n=e.querySelector("textarea");n&&((e=document.createElement("button")).classList="btn-copy",e.setAttribute("data-clipboard-target","#"+n.id),e.setAttribute("title","Copy code block content"),e.innerText="Copy",t.appendChild(e))});var clipboard=new ClipboardJS(".btn-copy");clipboard.on("success",function(e){e.trigger.innerText="Copied!",setTimeout(function(){e.trigger.innerText="Copy"},2e3),e.clearSelection()})</script>
</html>